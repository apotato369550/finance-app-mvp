# /types - TypeScript Type Definitions

## Purpose
Centralized TypeScript interfaces and types used across the entire application. Ensures type safety and consistency between frontend, backend, and database layers.

## Current Type Definitions (index.ts)

**User Types:**
- `User` - Core user object with id, email, onboarding status

**Quiz/Onboarding Types:**
- `QuizAnswer` - Single quiz answer (questionId + answer)
- `QuizResult` - Complete quiz submission with all answers
- `OnboardingQuestion` - Question structure with text, type, options, category
- `OnboardingResponse` - Database shape for individual answer records
- `OnboardingProfile` - Generated profile with personality, recommendations, strengths
- `ResponseType` - Union type for answer types: "text" | "number" | "choice" | "scale_1_5" | "scale_1_10"
- `QuestionCategory` - Union type: "mindset" | "behavior" | "numbers" | "goals"

**Content Types:**
- `Fund` - Investment fund information
- `ContentItem` - Educational content articles/resources

## Type Patterns

**Database Entities:**
- Optional `id` (generated by database)
- Required `user_id` for user-owned records
- Timestamps: `created_at`, `updated_at`
- Use `?:` for optional fields

**Union Types:**
- Use for restricted string values (e.g., ResponseType, QuestionCategory)
- Provides autocomplete and type safety
- Better than raw strings

**Interfaces vs Types:**
- Prefer `interface` for object shapes (can be extended)
- Use `type` for unions, primitives, complex compositions

## Common Tasks

**Adding a new type:**
1. Decide if it's an interface or type alias
2. Add to index.ts with clear name
3. Export it
4. Document with JSDoc comment if complex
5. Use in relevant files (components, API routes, lib)
6. Update this CLAUDE.md if significant addition
7. Update CHANGELOG.md

**Modifying existing type:**
1. Assess impact (search for usage)
2. Update interface in index.ts
3. Fix any TypeScript errors in consuming code
4. Consider backward compatibility for database types
5. Update CHANGELOG.md

**Database schema alignment:**
- Keep types aligned with Supabase tables
- Mirror column names and types
- Use optional fields for nullable columns
- Match JSONB fields with appropriate TypeScript types

## Type Safety Guidelines

**Be Explicit:**
- Avoid `any` type (defeats purpose of TypeScript)
- Use `unknown` if truly unknown, then narrow with type guards
- Define proper interfaces rather than inline types

**Use Union Types:**
- For restricted string values
- For variant shapes (discriminated unions)
- Better than enums in most cases

**Optional vs Required:**
- Use `?:` for truly optional fields
- Consider providing defaults instead of optional
- Required fields enforce data integrity

**Generic Types:**
- Use when type should be flexible but consistent
- Example: `Response<T>` for API responses

## API Response Patterns

**Success Response:**
```typescript
{ success: true, data: T }
```

**Error Response:**
```typescript
{ error: string }
```

Consider defining these as generic types if used widely.

## Type Organization

**Current Structure:**
- All types in single index.ts
- Works well for small projects
- Easy to find and import

**Future Consideration:**
If types grow significantly, consider splitting by domain:
- `/types/user.ts`
- `/types/onboarding.ts`
- `/types/content.ts`
- `/types/index.ts` (re-exports all)

## Type Guards

When needed, create type guard functions:
```typescript
function isUser(obj: unknown): obj is User {
  return typeof obj === 'object' && obj !== null && 'id' in obj
}
```

Use in API routes and utilities for runtime validation.

## Related Files
- Database: `/supabase/migrations/` - Schema definitions these types mirror
- API Routes: `/app/api/` - Use these types for request/response
- Components: `/app/`, `/components/` - Use for props and state
- Utils: `/lib/` - Use in function signatures

## Gotchas
- TypeScript types are compile-time only (don't exist at runtime)
- Database types may have subtle differences (Date vs string, etc.)
- Optional fields in TypeScript don't guarantee database nullability
- Need runtime validation for user inputs (use Zod, Yup, or manual checks)

**Remember:** Update CHANGELOG.md after adding or modifying type definitions.
